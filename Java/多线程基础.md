# 1.0 基础知识
## 1.1 引入
进程是操作系统结构的基础，是一次程序的执行。进程是受操作系统管理的基本运行单元。
线程是在进程中独立运行的子任务。

使用多线程的好处是可以最大限度地利用CPU的空闲时间来处理其他的任务。多线程是异步处理。

一个进程正在运行的时候至少有一个线程在运行。

实现多线程的编程的方式主要有两种：
- 继承Thread类
- 实现Runable接口
实际上，Thread类也继承了Runable接口。因为Java不支持多继承，当一个欲创建线程类已经有一个父类，这时就不能继承Thread类，需要实现Runable接口。

使用多线程技术时，代码的运行结果与代码执行顺序或调用顺序是无关的。CPU是以随机的不确定的顺序来执行线程。
Main也是一个线程。

Thread类中的start方法通知线程规划器，此线程已经准备就绪，等待调用线程对象的run方法。
执行start方法不代表线程启动的顺序。run方法是自动调用的方法。

实例变量有共享和不共享之分。不共享意味着不存在多个线程访问同一个实例变量。共享意味着多个线程访问同一个变量。

synchronized可以再任意对象以及方法上加锁。通过在run方法前加入synchronized关键词，使得多个线程在执行run方法时，以排队的方式进行处理。
当一个线程调用run前，先判断run方法有没有被上锁，如果上锁，说明由其他线程正在调用run方法，必须等其他线程对run方法调用结束后才可以执行run方法。

非线程安全，多个线程对同一个对象中的同一个实例进行操作时会出现值被更改，值不同步的情况，进而影响程序的执行流程。

## 1.2 基本方法
- currentThread返回代码段正在被哪个线程调用的信息。
- isAlive判断当前的线程是否处于活动状态。活动状态是指线程已启动且尚未终止。
- sleep可以使线程暂停执行指定的毫秒数。
- getId取得线程的唯一标识
- 停止线程：
  - stop方法已经被弃用。
  - 用interrupt中断线程，但interrupt并不能真的停止线程，仅仅是在当前线程中标记停止flag。
  - 可以用循环语句检查线程状态，如果进入停止状态，不再执行，立即break退出。
  - 利用try/catch机制，推荐使用。
  - 利用return
- interrupted测试当前线程是否已经中断，并清除线程的中断状态。如果紧接着再次调用，会返回false。
- isInterrupted测试线程Thread对象是否已经中断，不清除状态标志。
- suspend暂停线程/resume恢复线程执行。使用不当会独占资源，使得别的线程无法访问公共同步对象。
- yield方法放弃当前CPU资源，将它让给其他的任务去占用CPU执行时间。但放弃时间不确定，有可能刚刚放弃，马上又获得CPU时间片。

## 线程
CPU优先执行优先级别高的线程对象中的任务。设置优先级有助于帮“线程规划器”确定在下一次选择哪一个进程来优先执行。

在Java中优先级别分为1-10十个级别。线程的优先级具有继承性。

setPrioirty设置线程的优先级别。高优先级的线程优先享用CPU资源。

Java有两种线程，一种是用户线程，一种是守护线程。守护线程会在当前进程中不存在非守护线程的时候自动销毁。



# 2.0 并发访问
非线程安全会在多个线程对同一个对象中的实例变量进行并发访问时候发生，后果是语句取到的数据前后不一致。

非线程安全出现在实例变量中。如果是方法内部的私有变量，则不存在线程安全的问题。

两个线程在访问同一个对象中的同步方法时候，一定是线程安全的。

两个线程分别访问同一个类的不同实例，同异步的方式运行。

通过synchronized声明的方法一定是排队运行的。只有共享资源的读写才需要同步化，如果不是共享资源，根本没有同步的必要。

**线程锁的是对象**

使用synchronized的时候，当一个线程得到一个对象锁后，再次请求此对象锁时，是可以再次得到该对象的锁的。不支持锁重入的话，会陷入死锁。
当存在父子继承关系时候，子类可以通过锁重入机制调用父类的同步方法。同步方法不具备继承性。

当一个线程执行的代码出现异常的时候，其所持有的锁会自动释放。

## 2.1 synchronized
synchronized方法会对当前对象加锁，有时候会占用大量的资源。
可以使用synchronized代码块来对某一个对象加锁，当一个线程访问object的一个synchronized同步代码块，另一个线程仍然可以访问该object的非同步代码块。
当一个线程访问object的一个synchronized（this）同步代码块时，其他线程对同一个object中所有其他synchronized（this）同步代码块的访问将被阻塞。
和synchronized方法一样，synchronized（this）代码块锁的也是当前对象。

使用任意对象作为对象监视器synchronized（x）。持有不同对象监视器是异步的。
- 当多个线程同时执行synchronized（x）同步代码块，同步效果。
- 当其他线程执行x对象中synchronized方法，同步效果。
- 当其他线程执行x对象方法里面的synchronized（this）代码块时，同步效果。

将synchronized关键词加到static静态方法上，是给这个class类上锁。

String常亮池会带来死锁的问题。一般不使用String作为锁的对象。

死锁：不同的线程在等待根本不可能被释放的死锁，从而导致所有的任务都无法继续完成。在设计程序的时候，要避免双方互相持有对方的锁的情况。

只要对象不变，即使对象的属性被改变，运行的结果还是同步的。

## 2.2 volatile
volatile增加实例变量在多个线程之间的可见性，但不支持原子性。

多线程访问volatile不会发生阻塞，synchronized会发生阻塞。

volatile解决的是变量在多个线程之间的可见性。用多线程读取共享变量时，获得最新值使用。
只能保证JVM虚拟机从主内存加载的数据是最新的，不能保证获得之后，主内存的值不被改变。

synchronized代码块具有volatile同步功能


# 3.0 线程通信
使线程之间进行通讯，可以最大化地利用CPU利用率的同时，还可以更加精准地控制各线程的行为。

# 3.1 等待and通知机制
如果Thread依靠内部条件才能停止，它必须不停发出request，这浪费了CPU资源。

wait使当前执行代码的线程进行等待，并放在预执行队列，并在wait所在的代码行停止执行，直到接到通知或被中断为止。
在调用wait之前，线程必须获得该对象的对象级别锁。在执行wait方法后，当前线程释放锁。

notify通知那些可能等待该对象的对象锁的其他线程。在调用之前也必须获得对象锁。如果有多个对象等待，随机挑选一个。
在执行notify方法后，当前线程不会马上释放对象锁，wait线程也不能马上获得对象锁，需要等到notify执行完毕才行。


# 4.0 Lock的使用

