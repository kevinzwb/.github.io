缓存是将程序或系统经常调用的对象存在内存中，以便其使用时可以快速调用，不必再去数据库查询。这样做可以减少系统开销，提高系统效率。
凡是位于速度相差较大的系统层级之间，用于协调两者数据传输速度差异的结构，均可被成为缓存。
高速缓存文件置换机制是电脑处理缓存内存的一种机制.两个评价缓存机制的指标,击中率和召回成本. 
击中率描述缓存对象被查询的频率. 召回成本描述,返回击中对象的时间.

- Query Cache
  - 以SQL作为查询key值缓存查询结果
  - 一旦查询涉及的表记录被修改，缓存就会被自动删除
  
- data Buffer
  - 数据库数据在内存的容器
  - 命中率直接决定最终性能
  
  一个缓存系统应该尽可能保留那些未来最有可能被访问的keys,那些未来极少可能被访问的数据应该被移除.
  *但是缓存系统无法预测未来*

# 数据库缓存

# 需要考虑的问题
## 格式和访问模式
  1. 线程安全，当缓存的内容可以被多个线程访问时，使用某种锁定机制来保证数据不会被两个线程同时操作
  2. 序列化，当一个对象缓存时，需要将它序列化以便于保存
  3. 规格化缓存数据，要保证数据的格式是优化过的。
    - 储存成本
    - 索引成本

## 内容加载
- 提前加载将所有的数据加载到缓存中，在应用程序或线程的生存期内一直缓存。
- 动态加载，当请求数据时候，提取数据，并且将它缓存起来以备后续使用。

## 过期策略和清除策略
- 如果缓存满了，而且又没有缓存命中，那么就会按照某一种策略，把缓存中的旧的对象剔除，而把新的对象加入缓存池。


# 缓存算法/策略
## Least Frequently Used(LFU)
计算每个缓存对象的使用频率，把最不常用的缓存对象踢走。核心思想“如果数据过去被访问很多次，那么将来被访问的频率也更高”。
LFU的每一个数据块都有一个引用计数，数据块按照引用计数排序，具有相同引用计数的数据块按照时间排序。
 > - 新加入的数据插入队列尾部，计数初始化为1
 > - 队列中的数据被访问后，其引用计数增加，队列重新排序
 > - 当需要淘汰数据时候,将已经排序的列表最后的数据块删除
 一般情况下,LFU的效率要优于LRU,且能够避免周期性或者偶发性的操作导致缓存命中率下降的问题.
 LFU需要记录数据的历史访问记录,一旦数据访问模式改变,LFU需要更长时间来适用新的访问模式(历史数据会影响将来的数据的缓存污染效用).
 
 需要维护一个队列记录所有数据的访问记录,每个数据都需要维护引用计数并排序.内存消耗高,性能消耗高.

## Least Recently Used(LRU)
根据数据的历史访问记录来淘汰最近最少使用的缓存对象。核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”
> - 新数据加入链表头部
> - 每当缓存命中,则将数据移到链表头部
> - 当链表满的时候,将链表尾部的数据丢弃
当存在热点数据时，LRU的效率很好，但是偶发性，周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重.
命中需要遍历链表,找到命中的数据块索引,让那后需要将数据移到头部.
LRU算法淘汰最少被访问的key,也就是有最大空闲周期的key.


> *假定存在时间局限性原理,cache替换算法需要分辨哪些是访问频率高的数据,哪些是访问频率低的数据.因此需要能自动根据访问规律的改变对cache进行调整*

## LRU-K
额外需要一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。
当需要淘汰数据时候，LRU-K会淘汰第K次访问时时间距当前时间最大的数据。
> - 当数据第一次被访问时,加入到访问历史列表
> - 如果数据在访问历史列表里没有达到K次访问,按照LRU淘汰
> - 当访问历史队列中的数据访问次数达到K次后,将数据索引从历史队列删除,将数据移到缓存队列中,并缓存此数据.
    缓存队列重新按照时间排序
> - 缓存数据队列中被再次访问后,重新排序
> - 需要淘汰数据时候,淘汰缓存队列中排在末尾的数据
LRUK需要记录那些被访问过,但还没有放入缓存的对象,内存消耗大.
实际应用中，LRU-2比较平衡。把被访问过两次的对象放入缓存池，当缓存池满了之后，把两次最少使用的缓存对象踢走。
LRU-3的命中率更高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。


## Two Queues
两个缓存队列，首先是FIFO队列，其次是LRU队列。
把被访问的数据放到FIFO的缓存中，如果对象被再一次访问，将该对象转移到第二个，更大的LRU缓存中。
两个队列按照自己的方法淘汰数据。
 > - 新访问的数据插入到FIFO队列
 > - 如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰。
 > - 如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部
 > - 如果数据在LRU队列再次被访问，则将数据移到LRU队列头部
 > - LRU队列淘汰末尾的数据

## Most Recently Used
移除最近最多被使用的对象

## First in First out
把最陈旧的对象删除，添加新的对象。 核心思想“最近刚访问的，将来访问的可能性比较大”

## Second Chance
基于FIFO，额外添加一个flag，删除最陈旧的没有被最近被使用过额对象

## Time based
通过绝对的时间按的周期去删除过期的对象


## Clock 
采用一个循环链表,有一个指针指向最早的对象,且每个缓存中的对象都维护一个标记位. 
当待缓存对象在缓存中,无论该对象标记为0还是1,都被设置为1.同时,指针指向该对象的下一个对象.
若不在缓存中,检查指针指向对象的标记位.如果是0,则用待缓存兑现替换该对象.
如果是1,则置为0,指针指向下一个对象.如此直至淘汰一个对象为止.

## GClock
GClock基于Clock,采用整数计数的标志位.当待缓存对象在缓存中,把其标记位的值加1.同时,指针指向该对象的下一个对象.
若不在缓存中时,检查指针指向对象的标记位.如果是0,则用待缓存对象替换对象；否则,把标记位的值减1,指针指向下一个对象.
如此直到淘汰一个对象位置.
由于标记位的值允许大于1,所以指针可能循环多遍才淘汰一个对象.

## WSclock
采用循环链表.每个缓存对象保存了"最近使用的时间" 和 " 是否引用" 的标志位,使用一个周期计时器t. 
age表示当前时间和rt的差值.
> - 当待缓存对象存在缓存中,更新rt为当前时间.
> - 指针指向该对象的下一个对象
> - 若不存在于缓存中,如果缓存没满,则更新指针指向位置的rt为当前时间,R为1.
> - 指针指向下一个对象.如果满了,需要淘汰一个对象.
> - 检查指针指向的对象.
    - 如果R为1,说明对象在working set,重置R为0,指针指向下一个对象
    - 如果R为0,如果age >  t,对象不在working set,替换该对象,并置R为1,rt为当前时间. 如果age <= t,继续寻找淘汰对象
    - 如果指针回到起始位置,仍未寻找到淘汰对象,则淘汰遇到的第一个R为0的对象.
    
    
 
 ## Maybe Helpful
 - [Java 中常用缓存Cache机制的实现](http://blog.csdn.net/zane3/article/details/76176203)
 - [Redis中的LRU算法改进](http://blog.csdn.net/qq_35440678/article/details/53453107)
 - [LRU的改进算法LIRS](http://blog.csdn.net/IT_YUAN/article/details/8488876)
 - [LRU-K，2Q，LIRS算法介绍与比较](http://blog.csdn.net/Pun_C/article/details/50920469)
